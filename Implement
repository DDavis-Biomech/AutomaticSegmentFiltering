 % Implement 
% ---------
%
%   Using data with raw displacement and reference acceleration this code: 
%       1) Computes a Butterworth filter cut-off frequency using the
%       autocorrelation-based procedure (Challis, 1999) and applies that
%       filter to the data. Compares estimate to reference.
%       2) Utilizes Teager Energy to compute segment change-points in
%       dataset then conducts ABP on each segment. Finally, joins segments
%       together to create an estimate and compares it to reference.
%       3) Outputs a plot of the Teager-Kaiser Energy Operator and
%       acceleration estimates along with error for each estimate compares
%       to the reference.
%      
%


close all
clear

% set global parameters
global fs dt forder Time

%% LOAD DATA

file = 'TestDataSet2.xls';      % data set from Dowling (1985)
data = xlsread(file);
Time = data(:,1);
RawDisplace = data(:,2);
nAccelRef = data(:,3);

% integrated to compute velocity and displacement from reference data
VelocRef = cumtrapz(Time,nAccelRef);
DisplaceRef = cumtrapz(Time,VelocRef)+RawDisplace(1,1);

% data collection parameters
fs = 512; 
dt = 1/fs;

% Butterworth filter order (recursive so is effectively doubled)
forder = 2;

% filter reference data to reduce any remaining noise
[AccelRef, coRef] = filtmat_auto(dt, forder, nAccelRef);

% compute difference between raw reference and filtered reference
% acceleration for the entire signal, the signal minimum, and the signal
% maximum
Ref_error = prmse(AccelRef, nAccelRef);
minRef_error = abs((min(AccelRef) - min(nAccelRef)) / (min(AccelRef))) * 100;
maxRef_error = abs((max(AccelRef) - max(nAccelRef)) / (max(AccelRef))) * 100;


%% SINGLE FILTER APPROACH USING ABP
               
% determines 'optimal' filter cut-off frequency (coABP) for full signal and applies it,
% creating a new displacement estimate
[ ABP_DisplEstim, coABP ] = filtmat_auto( dt, 2, RawDisplace);

% use cut-off to filter and double-differentiate the data
ABP_AccelEstim =  fdiff2(dt, coABP, 2, RawDisplace);         

% calculate error between single-filter ABP and criterion
[ ABP_error ] = prmse(AccelRef, ABP_AccelEstim);

% compares the mins and maxes of criterion and single-filter ABP estimate
minABP_error = abs((min(AccelRef) - min(ABP_AccelEstim)) / (min(AccelRef))) * 100;
maxABP_error = abs((max(AccelRef) - max(ABP_AccelEstim)) / (max(AccelRef))) * 100;

%  Display analysis statistics  %
disp( '   -------------------')
disp( ['      Cut-off frequency ',num2str(coABP)  ,' Hz'] )
disp( ['Second Order Derivative %Root Mean Square Error ',num2str(ABP_error),' % '] )
disp( ['Signal Minimum %Error ',num2str(minABP_error),' % '] )
disp( ['Signal Maximum %Error ',num2str(maxABP_error),' % '] )
disp( '   -------------------')

%%  ABP-BASED SEGMENT FILTERING     

% Estimate displacement and acceleration 
[TKEO,MAD3, SegFilt_DEstim, SegFilt_AEstim, CPs, fco ] = segfilt_estim(RawDisplace);

%% COMPUTE ERRORS %%

% Segment filtering whole signal accel error
[ SegFilt_Aerror ] = prmse(AccelRef, SegFilt_AEstim);

% Segment by segment errors
% initialize
segfilt_segAerr = zeros(1,length(CPs)+1);
ABP_segAerr = zeros(1,length(CPs)+1);

% First Segment
segfilt_segAerr(1) = prmse(AccelRef(1:CPs(1)), SegFilt_AEstim(1:CPs(1)));         
ABP_segAerr(1) = prmse(AccelRef(1:CPs(1)), ABP_AccelEstim(1:CPs(1)));

for e = 2:length(CPs)
    
% Middle Segments
segfilt_segAerr(e) = prmse(AccelRef(CPs(e-1)+1:CPs(e)), SegFilt_AEstim(CPs(e-1)+1:CPs(e)));       
ABP_segAerr(e) = prmse(AccelRef(CPs(e-1)+1:CPs(e)), ABP_AccelEstim(CPs(e-1)+1:CPs(e)));

end

% Last Segment
segfilt_segAerr(end)  = prmse(AccelRef(CPs(end)+1:end), SegFilt_AEstim(CPs(end)+1:end)); 
ABP_segAerr(end) = prmse(AccelRef(CPs(end)+1:end), ABP_AccelEstim(CPs(end)+1:end));

segAerr = [segfilt_segAerr; ABP_segAerr];


% compares the mins and maxes of criterion and estimate
min_segfilt_error = abs((min(AccelRef) - min(SegFilt_AEstim)) / (min(AccelRef))) * 100;
max_segfilt_error = abs((max(AccelRef) - max(SegFilt_AEstim)) / (max(AccelRef))) * 100;


%   display analysis statistics  %
disp( '   -------------------')
disp( ['      Cut-off frequencies [',num2str(fco),' Hz]'] )
disp( ['Second Order Derivative %Root Mean Square Error ',num2str(SegFilt_Aerror),' % '] )
disp( ['Signal Minimum %Error ',num2str(min_segfilt_error),' % '] )
disp( ['Signal Maximum %Error ',num2str(max_segfilt_error),' % '] )
disp( '   -------------------')
disp( '   -------------------')
array2table(segAerr)
